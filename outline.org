#+STARTUP: beamer
#+TITLE: Testing native binaries using CFFI
#+AUTHOR: Noufal Ibrahim
#+OPTIONS: H:2 toc:t num:t
#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [presentation]
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usefonttheme{serif} % default family is serif
#+LATEX_HEADER: \lstset{basicstyle=\tiny \ttfamily, showspaces=false, showstringspaces=false, keywordstyle=\color{blue}, commentstyle=\color{gray}, stringstyle=\color{magenta}, frame=single}
#+BEAMER_THEME: Singapore

* Introduction
** About me
   - Founder of Hamon Technologies and Co founder of Pipal Academy.
   - Automation/Infrastructure/IoT work and trainings.
   - Also mentor students via. The Lyc\ae{}um.
   - Long time Python user and been involved with PyCon since the
     first conference.
   - Amateur Calligrapher.
** Coupling between languages
   - Web based APIs.
   #+BEAMER: \pause         
   - IPC
   #+BEAMER: \pause
   - Common runtime
   #+BEAMER: \pause
   - True FFI
** An aside - language wars
   - Language warriors *vs* Languages themselves
   #+BEAMER: \pause
   - The *real* barrier for cooperation is stuck up programmers. Not
     languages or technologies.
** About the talk
   - Using Python testing tools to test libraries in lower level languages.
   - The [[https://github.com/nibrahim/cpslib][cpslib]] library (C) and its tests (python).
   - About ways of interfacing C and Python.
** Cpslib
   - cpslib is a port of psutil to C.
   - Allows you to query process and system information in a cross
     platform fashion (e.g. number of CPUs etc.)
   - Example

     #+BEGIN_SRC c
       uint32_t cpu_count(bool);

       void main() 
       {
         uint32_t physical;
         physical = cpu_count(false);
         printf("Physical : %" PRIu32 "\n", physical);
       }

     #+END_SRC
   - The original idea was to make it compatible with psutils.
   - So we have something to test against.

* FFI in Python
** Ctypes 
   - The Python stdlib ffi module.
   - Example wrapping
  #+BEGIN_SRC python
   cdll = ctypes.CDLL("./libpslib.so")
   cdll.cpu_count(True) # 4
   cdll.cpu_count(False) # 1
  #+END_SRC
   - A little more complex with compound types

** Leftpad
  #+BEGIN_SRC c
    char * left_pad_string(char *ip, size_t ip_count, size_t pad_count)
    {
      char * ret;
      uint32_t i, j;
      ret = (char *)calloc(pad_count, sizeof(char));
      for (i=0; i<(pad_count - ip_count); i++) {
        ret[i] = ' ';
      }
      for (j=0; j<ip_count; j++, i++) {
        ret[i] = ip[j];
      }
      ret[i] = '\0';
      return ret;
    }
  #+END_SRC

  #+BEGIN_src shell
  $ gcc -fPIC -shared -std=gnu11 -Wall -Wextra -Wunused -o libleftpad.so leftpad.c
  #+END_SRC

  #+BEGIN_SRC python
  from ctypes import *
  leftpad = CDLL("./libleftpad.so")

  leftpad.left_pad_string.argtypes = [c_char_p, c_size_t, c_size_t]
  leftpad.left_pad_string.restype = c_char_p

  def leftpad(ip):
      ip = ip.encode('ascii')
      ret = c_leftpad.left_pad_string(ip, len(ip), 15)
      return ret.decode('ascii')

  print ("'%s'"%(leftpad("python"))) # '         python'
  #+END_SRC

** Standard library
 - Works on pypy, cpython and even jython.
 - This is great. Why cffi then?
** CFFI 
   - CFFI has some advantanges
   #+BEAMER: \pause
   - No DSL (=c_size_t= etc.)
   #+BEAMER: \pause
   - Can work at =API= or =ABI= level. The former is more portable.
   #+BEAMER: \pause
   - Apparently faster because of custom code.
** CFFI using ABI
   - Similar to ctypes
#+BEGIN_SRC python
  import cffi

  ffi = cffi.FFI()
  ffi.cdef("char *left_pad_string(char *ip, size_t ip_count, size_t pad_count);")

  c_leftpad = ffi.dlopen("./libleftpad.so")

  def leftpad(ip):
      ip = ip.encode('ascii')
      op = c_leftpad.left_pad_string(ip, len(ip), 20)
      return ffi.string(op).decode('ascii')
#+END_SRC
   - We have to guess memory layout and calling conventions here.
   - This is hard to get right
   - The compiler is what usually does this for us
** CFFI Using API  
   - We need a build script for this
#+BEGIN_SRC python
  from cffi import FFI

  ffi = FFI()
  ffi.set_source('pyleftpad', '',
                 libraries=["leftpad"],
                 library_dirs=['.'])

  ffi.cdef("char *left_pad_string(char *ip, size_t ip_count, size_t pad_count);")

  if __name__ == '__main__':
      ffi.compile()
#+END_SRC
  - Run this to get a =pyleftpad.so=. A native C extension. 
#+BEAMER: \pause
  - Yup. No more manual C extensions and
#+BEAMER: \pause
  - The build scripts can generate C extensions compatible with PyPy
    too.
** Using the generated C extension
   #+BEGIN_SRC python
     import pyleftpad # Loads a native C extension

     def leftpad(ip):
         ip = ip.encode('ascii')
         # Don't forget the .lib.
         op = pyleftpad.lib.left_pad_string(ip, len(ip), 20)
         return pyleftpad.ffi.string(op).decode('ascii')
    #+END_SRC
** Some quick performance numbers
#+BEGIN_SRC python
# perf.py
import timeit

from leftpad_ctypes import leftpad as ctypes_leftpad
from leftpad_cffi_abi import leftpad as cffi_abi_leftpad
from leftpad_cffi_api import leftpad as cffi_api_leftpad

print ("CFFI API", timeit.timeit(lambda : cffi_api_leftpad("python")))
print ("CFFI ABI", timeit.timeit(lambda : cffi_abi_leftpad("python")))
print ("Ctypes ", timeit.timeit(lambda : ctypes_leftpad("python")))
#+END_SRC

#+BEGIN_EXAMPLE
CFFI API 2.052793896989897
CFFI ABI 2.603409282004577
Ctypes   2.907925626001088
#+END_EXAMPLE

* Testing libraries
** The general approach
   - =set_source= for headers and =cdef= for all declarations
   - Build native extension.
   - Load it up and use it inside python
   - An example test for =left_pad_string= would be

#+BEGIN_SRC python
  # test_leftpad
  from leftpad_cffi_api import leftpad

  def test_leftpad():
      ip = "python"
      assert leftpad(ip) == ip.rjust(20)
#+END_SRC

   - Can be run using =py.test=
   - Higher level abstractions are usually a good idea.

** Testing cpslib
#+BEGIN_SRC python
import psutil
from pycpslib import lib as P 

def test_boot_time():
    pslib_boot_time = P.get_boot_time()
    psutil_boot_time = psutil.boot_time()
    
    assert pslib_boot_time == psutil_boot_time
#+END_SRC
  - Useful to prevent regressions.
  - For feature parity.
  - To verify functionality on new kernels/platforms.
* Some extras
** Test coverage
   - =gcov= allows us to measure coverage of C files.
   - You compile with a few extra flags 
     #+BEGIN_EXAMPLE
     gcc -fprofile-arcs -ftest-coverage -o leftpad leftpad.c
     #+END_EXAMPLE
   - Compiling it will produce a =.gcno= file (the call graph)
#+BEAMER: \pause
   - Then run it =./leftpad=
   - You'll get a =.gcda= file (the actual data)
#+BEAMER: \pause
   - Then run =gcov leftpad= (human readable output)
#+BEAMER: \pause
   - And you'll finally get coverage data in  =leftpad.c.gcov=
** =pytest-gcov= 
   - This is a simple =py.test= plugin.
   - It will automatically do all this for you and print coverage
     statistics at the end.
   - Lots of limitations but "works for me".
** Language barriers
   - Once you get the =.so=, =cffi= will work.
   - Needn't be generated from C. 


* TODO 
  - [ ] Why the warnings when compiling the module?
  - [ ] Demo with PyPy as well 
     
  


